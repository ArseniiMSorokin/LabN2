## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2402`

#### Выполнил: `Сорокин Арсений Михайлович`

#### Вариант: `23`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Математическая модель и описание алгоритмов](#4-математическая-модель-и-описание-алгоритмов)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи
#### Условие задачи
> Напишите программу на Java, которая выполняет следующие действия с
двумерным массивом целых чисел, представляющим матрицу смежности
графа:
> 1. Считывает с консоли размер матрицы N , затем элементы матрицы размером N × N.
> 2. Проверяет, является ли граф, заданный матрицей, эйлеровым, и выводит результат.
> 3. Находит и выводит степень каждой вершины графа.
> 4. Выводит список рёбер графа.
> 5. Строит и выводит матрицу достижимости графа.

### 2. Входные и выходные данные
#### Входные данные

|                 | Тип              | min значение    | max значение |
|-----------------|------------------|-----------------|--------------|
|       N         | Целое число      | -2147483648     | 2147483647   |
| matrix (Массив) | Двумерный массив | -128            | 127          |

#### Выходные данные
|                               | Тип                       | min значение  | max значение |
|-------------------------------|---------------------------|---------------|--------------|
| grUndirected                  | Логический тип            | false         | true         |
| eulUnDir                      | Логический тип            | false         | true         |
| eulDir                        | Логический тип            | false         | true         |
| Числа (степени вершин)        | Целочисленное число       | -2147483648   | 2147483647   |
| Числа (рёбра графа)           | Целочисленное число       | -2147483648   | 2147483647   |
| Числа (матрица достижимости)  | Двумерный массив          | -128          | 127          |

### 3. Выбор структуры данных
|                | Тип          |
|----------------|--------------|
| grUndirected   | boolean      |
| eulUnDir       | booolean     |
| eulDir         | boolean      |
| deg            | integer      |
| oddDegCo       | integer      |
| matrix         | byte [][]    |
| reachMatrix    | byte [][]    |
| inDeg          | integer []   |
| outDeg         | integer []   |
- Числа deg и oddDegCo - integer, потому что не может быть не целого числа вершин у графа.
- grUndirected, eulUnDir, eulDir - boolean, так как проверяют состояние условия, соответственно выводят true/false
- matrix - целочисленный двумерный массив (из условия)
- inDeg и outDeg - обозначают целочисленный массив, состоящий из целочисленных элементов показывающих сколько рёбер входят/исходят из вершины.
- reachMatrix - целочисленный двумерный массив, содержит 1 или 0 в зависимости от того, можно ли достигнуть из данной вершину другую, используется byte а не integer, так как значения в матрице ограничены 0 и 1 и не выходят за пределы byte.



### 4. Математическая модель и описание алгоритмов
#### 4.1 Заполнение матрицы:
Заполнение матрицы происходит при помощи вложенного цикла считываются числа и сохраняются в матрицу.
#### 4.2 Определение является ли граф ориентированным или неориентированным:
Если матрица смежности равна её транспонированной версии, то граф является неориентированным, если нет то граф считается ориентированным.
В программе проверяется элемент c индексом i и j (номер элемента в строке и столбец соответственно) и его транспонированная версия с индексами j и i. Если хотя бы один элемент не будет равен его
транспонированной версии -> граф ориентированный.
#### 4.3_a Если граф Неориентированный:
##### 4.3_a.1 Проверка является ли граф Эйлеровым:
- Неориентированный граф является Эйлеровым если он содержит либо две, либо ни одну вершину с нечётной степенью. Для проверки этого условия используется цикл, который суммирует значения в строке матрице, если оно получилось нечётным, то увеличивается счётчик нечётных вершин, вводится переменная которая выводит true, если количество вершин с нечётной степенью равно 0 или 2, false в остальных случаях. true или false и будет Эйлеровостью/не Эйлеровостью графа.
##### 4.3_a.2 Вывод степени вершин графа:
- Вычисляется так же, как и в предыдущем пункте (суммирование значений в строке матрицы)
##### 4.3_a.3 Вывод списка рёбер графа:
- Во вложенном цикле (i,j) перебираются строки (второй цикл от +1 элемента от первого чтобы не было совпадений) и если значение в ячейке матрицы равно 1 выводится ребро i - j.
#### 4.3_b Если граф Ориентированный:
##### 4.3_b.1 Проверка является ли граф Эйлеровым:
- Вводится два одномерных массива inDeg и outDeg обозначающие входные и выходные степени вершины соответственно. Цикл с inDeg (j) обходит столбцы, а цикл с outDeg (i) обходит строчки, получаются списки,
- в которых первый элемент относится к первой вершине (входная и "выходная" степени), второй ко второй и так далее. Затем в цикле сравниваются элементы этих списков, если хоть один не совпадает -> граф
- не является Эйлеровым.
##### 4.3_b.2 Вывод степени вершин графа:
- Вычисляется так же, как и в предыдущем пункте (берутся элементы из inDeg и outDeg соответственно)
##### 4.3_b.3 Вывод списка рёбер графа:
- Во вложенном цикле (i,j) перебираются элементы построчно, если элемент matrix[i][j]==1 то значит ребро существует и идёт i-->j.

#### 4.4 Матрица достижимости
- Алгоритм Флойда Уоршелла. Алгоритм проходит через каждую вершину k, рассматривая ее как промежуточную вершину. Для каждой пары вершин (i, j) проверяется, существует ли путь от i к j, проходя через k.
- Если reachMatrix[i][k] равно 1 (то есть существует путь от i до k) и reachMatrix[k][j] равно 1 (существует путь от k до j), то устанавливается reachMatrix[i][j] в 1, что означает, что теперь есть путь от i до j, проходя через k.
- После выполнения алгоритма для всех вершин, матрица reachMatrix будет содержать информацию о достижимости: если reachMatrix[i][j] равно 1, это означает, что существует путь от вершины i до вершины j. Если равно 0, то путь отсутствует.

### 5. Программа

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[][] matrix = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                matrix[i][j] = sc.nextInt();
            }
        }
        boolean grUndirected = true;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (matrix[i][j] != matrix[j][i]) {
                    grUndirected = false;
                    break;
                }
            }
            if (!grUndirected) {
                break;
            }
        }
        if (grUndirected) {
            int oddDegCo = 0;
            for (int i = 0; i < N; i++) {
                int deg = 0;
                for (int j = 0; j < N; j++) {
                    deg += matrix[i][j];
                }
                if (deg % 2 != 0) {
                    oddDegCo++;
                }
            }
            boolean eulUnDir = (oddDegCo == 2 || oddDegCo == 0);
            System.out.println("(1) Неориентированный");
            System.out.println("(2) Эйлеровость : " + eulUnDir);
            System.out.println("(3) Степени вершин: ");
            for (int i = 0; i < N; i++) {
                int deg = 0;
                for (int j = 0; j < N; j++) {
                    deg += matrix[i][j];
                }
                System.out.println("    Вершина " + (i + 1) + ": " + deg + " - Степень");
            }
            System.out.println("(4) Список рёбер графа:");
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (matrix[i][j] == 1) {
                        System.out.println("    Ребро: " + (i + 1) + " - " + (j + 1));
                    }
                }
            }
        } else {
            boolean eulDir = true;
            int[] inDeg = new int[N];
            int[] outDeg = new int[N];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    inDeg[j] += matrix[i][j];
                    outDeg[i] += matrix[i][j];
                }
            }
            for (int i = 0; i < N; i++) {
                if (inDeg[i] != outDeg[i]) {
                    eulDir = false;
                    break;
                }
            }
            System.out.println("(1) Ориентированный");
            System.out.println("(2) Эйлеровость : " + eulDir);
            System.out.println("(3) Cтепени вершин");
            for (int k = 0; k < N; k++) {
                System.out.println("    Вершина: " + (k + 1) + ". Исходящая степень - " + outDeg[k] + ". Входящая степень - " + inDeg[k]);
            }
            System.out.println("(4) Список рёбер графа:");
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (matrix[i][j] == 1) {
                        System.out.println("    Ребро: " + (i + 1) + " -> " + (j + 1));
                    }
                }
            }
        }
        int[][] reachMatrix = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                reachMatrix[i][j] = matrix[i][j];
            }
        }
        for (int k = 0; k < N; k++) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (reachMatrix[i][k] == 1 && reachMatrix[k][j] == 1) {
                        reachMatrix[i][j] = 1;
                    }
                }
            }
        }
        System.out.println("(5) Матрица достижимости:");
        for (int i = 0; i < N; i++) {
            System.out.print("    ");
            for (int j = 0; j < N; j++) {
                System.out.print(reachMatrix[i][j] + "    ");
            }
            System.out.println();
        }
    }
}
```

### 6. Анализ правильности решения
#### Проведем тесты 
  
