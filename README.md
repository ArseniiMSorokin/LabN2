## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2402`

#### Выполнил: `Сорокин Арсений Михайлович`

#### Вариант: `23`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Математическая модель и описание алгоритмов](#4-математическая-модель-и-описание-алгоритмов)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи
#### Условие задачи
> Напишите программу на Java, которая выполняет следующие действия с
двумерным массивом целых чисел, представляющим матрицу смежности
графа:
> 1. Считывает с консоли размер матрицы N , затем элементы матрицы размером N × N.
> 2. Проверяет, является ли граф, заданный матрицей, эйлеровым, и выводит результат.
> 3. Находит и выводит степень каждой вершины графа.
> 4. Выводит список рёбер графа.
> 5. Строит и выводит матрицу достижимости графа.

### 2. Входные и выходные данные
#### Входные данные

|                 | Тип              | min значение    | max значение |
|-----------------|------------------|-----------------|--------------|
|       N         | Целое число      | -2147483648     | 2147483647   |
| matrix (Массив) | Двумерный массив | -128            | 127          |

#### Выходные данные
|                               | Тип                       | min значение  | max значение |
|-------------------------------|---------------------------|---------------|--------------|
| grUndirected                  | Логический тип            | false         | true         |
| eulUnDir                      | Логический тип            | false         | true         |
| eulDir                        | Логический тип            | false         | true         |
| Числа (степени вершин)        | Целочисленное число       | -2147483648   | 2147483647   |
| Числа (рёбра графа)           | Целочисленное число       | -2147483648   | 2147483647   |
| Числа (матрица достижимости)  | Двумерный массив          | -128          | 127          |

### 3. Выбор структуры данных
|                | Тип          |
|----------------|--------------|
| grUndirected   | boolean      |
| eulUnDir       | booolean     |
| eulDir         | boolean      |
| deg            | integer      |
| oddDegCo       | integer      |
| matrix         | byte [][]    |
| reachMatrix    | byte [][]    |
| inDeg          | integer []   |
| outDeg         | integer []   |
| visited        | boolean []   |
| startVe        | integer      |
| isConnected    | boolean      |
- Числа deg и oddDegCo - integer, потому что не может быть не целого числа вершин у графа.
- grUndirected, eulUnDir, eulDir - boolean, так как проверяют состояние условия, соответственно выводят true/false
- matrix - целочисленный двумерный массив (из условия)
- inDeg и outDeg - обозначают целочисленный массив, состоящий из целочисленных элементов показывающих сколько рёбер входят/исходят из вершины.
- reachMatrix - целочисленный двумерный массив, содержит 1 или 0 в зависимости от того, можно ли достигнуть из данной вершину другую, используется byte а не integer, так как значения в матрице ограничены 0 и 1 и не выходят за пределы byte.



### 4. Математическая модель и описание алгоритмов
#### 4.1 Заполнение матрицы:
Заполнение матрицы происходит при помощи вложенного цикла считываются числа и сохраняются в матрицу.
#### 4.2 Определение является ли граф ориентированным или неориентированным:
Если матрица смежности равна её транспонированной версии, то граф является неориентированным, если нет то граф считается ориентированным.
В программе проверяется элемент c индексом i и j (номер элемента в строке и столбец соответственно) и его транспонированная версия с индексами j и i. Если хотя бы один элемент не будет равен его
транспонированной версии -> граф ориентированный.
#### 4.3 Определение является ли граф связанным или нет:
Для начала проверяем в цикле есть ли связь у вершины с "начальной" и проверка, что текущая вершина не была уже посещена. Затем проверка различных вершин c связанных с i, и не посещена ли эта вершина j, потом проверка уже
для вершин связанных с j, и не посещена ли k. Если в конечном списке найдется хоть одна непосещённая, то граф не связанный.
#### 4.4_a Если граф Неориентированный:
##### 4.4_a.1 Проверка является ли граф Эйлеровым:
- Неориентированный граф является Эйлеровым если он содержит либо две, либо ни одну вершину с нечётной степенью. Для проверки этого условия используется цикл, который суммирует значения в строке матрице, если оно получилось нечётным, то увеличивается счётчик нечётных вершин, вводится переменная которая выводит true, если количество вершин с нечётной степенью равно 0 или 2, false в остальных случаях. true или false и будет Эйлеровостью/не Эйлеровостью графа.
##### 4.4_a.2 Вывод степени вершин графа:
- Вычисляется так же, как и в предыдущем пункте (суммирование значений в строке матрицы)
##### 4.4_a.3 Вывод списка рёбер графа:
- Во вложенном цикле (i,j) перебираются строки (второй цикл от +1 элемента от первого чтобы не было совпадений) и если значение в ячейке матрицы равно 1 выводится ребро i - j.
#### 4.4_b Если граф Ориентированный:
##### 4.4_b.1 Проверка является ли граф Эйлеровым:
- Вводится два одномерных массива inDeg и outDeg обозначающие входные и выходные степени вершины соответственно. Цикл с inDeg (j) обходит столбцы, а цикл с outDeg (i) обходит строчки, получаются списки,
- в которых первый элемент относится к первой вершине (входная и "выходная" степени), второй ко второй и так далее. Затем в цикле сравниваются элементы этих списков, если хоть один не совпадает -> граф
- не является Эйлеровым.
##### 4.4_b.2 Вывод степени вершин графа:
- Вычисляется так же, как и в предыдущем пункте (берутся элементы из inDeg и outDeg соответственно)
##### 4.4_b.3 Вывод списка рёбер графа:
- Во вложенном цикле (i,j) перебираются элементы построчно, если элемент matrix[i][j]==1 то значит ребро существует и идёт i-->j.

#### 4.5 Матрица достижимости
- Алгоритм Флойда Уоршелла. Алгоритм проходит через каждую вершину k, рассматривая ее как промежуточную вершину. Для каждой пары вершин (i, j) проверяется, существует ли путь от i к j, проходя через k.
- Если reachMatrix[i][k] равно 1 (то есть существует путь от i до k) и reachMatrix[k][j] равно 1 (существует путь от k до j), то устанавливается reachMatrix[i][j] в 1, что означает, что теперь есть путь от i до j, проходя через k.
- После выполнения алгоритма для всех вершин, матрица reachMatrix будет содержать информацию о достижимости: если reachMatrix[i][j] равно 1, это означает, что существует путь от вершины i до вершины j. Если равно 0, то путь отсутствует.

### 5. Программа

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        // Создание объекта sc класса Scanner для ввода данных
        Scanner sc = new Scanner(System.in);
        // Cчитывается размер матрицы и записывается в переменную N
        int N = sc.nextInt();
        // Создается двумерный массив, который отображает матрицу N×N
        byte[][] matrix = new byte[N][N];
        // Вложенный цикл, который заполняет значения в матрицу построчно
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                matrix[i][j] = sc.nextByte();
            }
        }
        // Переменная для проверки на выполнение условия ориентированности графа
        boolean grUndirected = true;
        // Вложенный цикл для сравнения элемента матрицы с транспонированным элементом,
        // Если хотя бы один элемент не совпадёт, граф считается ориентированным и
        // переменная boolean меняет значение на false, иначе неориентированный и boolean остается true
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (matrix[i][j] != matrix[j][i]) {
                    grUndirected = false;
                    break;
                }
            }
            // Прерывание цикла, так как одного несовпадения достаточно, чтобы граф считался ориентированным
            if (!grUndirected) {
                break;
            }
        }
        // Проверка на не ориентированность графа
        if (grUndirected) {
            // Вводится переменная, которая обозначает количество четных вершин в графе
            int oddDegCo = 0;
            // Вложенный цикл для проверки каждого элемента матрицы
            for (int i = 0; i < N; i++) {
                // Переменная для подсчёта степени вершин в графе
                // Складываются все значения в строке матрицы, если оно нечётно, увеличиваем переменную oddDegCo на 1
                int deg = 0;
                for (int j = 0; j < N; j++) {
                    deg += matrix[i][j];
                }
                if (deg % 2 != 0) {
                    oddDegCo++;
                }
            }
            // Переменная типа boolean, которая проверяет что количество нечётных вершин
            // равно 2 или их вообще нет
            boolean eulUnDir = (oddDegCo == 2 || oddDegCo == 0);
            System.out.println("(1) Неориентированный");
            // Вывод переменной типа boolean true/false
            System.out.println("(2) Эйлеровость : " + eulUnDir);
            System.out.println("(3) Степени вершин: ");
            // Вложенный цикл работающий как на строке 39, только выводит степень вершины на экран
            for (int i = 0; i < N; i++) {
                int deg = 0;
                for (int j = 0; j < N; j++) {
                    deg += matrix[i][j];
                }
                System.out.println("    Вершина " + (i + 1) + ": " + deg + " - Степень");
            }
            System.out.println("(4) Список рёбер графа:");
            // Вложенный цикл, второй начинается от значения первого +1, чтобы не было повторений
            // рёбер графа, если значение элемента матрицы равно 1, то выводится ребро i - j
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (matrix[i][j] == 1) {
                        System.out.println("    Ребро: " + (i + 1) + " - " + (j + 1));
                    }
                }
            }
        } else {
            // Переменная типа boolean, которая будет обозначать является ли граф Эйлеровым или нет
            boolean eulDir = true;
            // Два целочисленных одномерных массива, обозначающих количество ребёр (входящих/исходящих)
            int[] inDeg = new int[N];
            int[] outDeg = new int[N];
            // Цикл, где в inDeg кладётся сумма значений столбца матрицы, а в outDeg сумма значений строки
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    inDeg[j] += matrix[i][j];
                    outDeg[i] += matrix[i][j];
                }
            }
            // Цикл, в котором сравнивается два массива по элементам с одинаковыми индексами,
            // если хотя бы один элемент не совпадёт -> переменная типа boolean принимает значение false
            // и выходит из цикла
            for (int i = 0; i < N; i++) {
                if (inDeg[i] != outDeg[i]) {
                    eulDir = false;
                    break;
                }
            }
            System.out.println("(1) Ориентированный");
            System.out.println("(2) Эйлеровость : " + eulDir);
            System.out.println("(3) Cтепени вершин");
            // Так как уже есть список с входящими/исходящими рёбрами то просто выводятся степени вершины
            for (int k = 0; k < N; k++) {
                System.out.println("    Вершина: " + (k + 1) + ". Исходящая степень - " + outDeg[k] + ". Входящая степень - " + inDeg[k]);
            }
            System.out.println("(4) Список рёбер графа:");
            // Циклы, проходящие по строкам матрицы и если элемент равен 1, то строится ребро i->j
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (matrix[i][j] == 1) {
                        System.out.println("    Ребро: " + (i + 1) + " -> " + (j + 1));
                    }
                }
            }
        }
        // Создание двумерного массива отображающего матрицу достижимости
        byte[][] reachMatrix = new byte[N][N];
        // Заполнение этого массива элементами из матрицы смежности
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                reachMatrix[i][j] = matrix[i][j];
            }
        }
        // Алгоритм Флойда-Уоршелла
        // k - промежуточная вершина, в цикле проверяется, существует ли путь от i до j через k,
        // если существует - устанавливается достижимость от i до j
        for (int k = 0; k < N; k++) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (reachMatrix[i][k] == 1 && reachMatrix[k][j] == 1) {
                        reachMatrix[i][j] = 1;
                    }
                }
            }
        }
        System.out.println("(5) Матрица достижимости:");
        // Вывод двумерного массива отображающего матрицу достижимости построчно
        for (int i = 0; i < N; i++) {
            System.out.print("    ");
            for (int j = 0; j < N; j++) {
                System.out.print(reachMatrix[i][j] + "    ");
            }
            System.out.println();
        }
    }
}
```

### 6. Анализ правильности решения
#### Проведем тесты 
1. ##### N=3, неориентированный:
- Input:
    ```
    3
    0 1 1
    1 0 1
    1 1 0
    ```
- Output:
    ```
    (1) Эйлеровость : true
    (2) Степени вершин: 
        Вершина 1: 2 - Степень
        Вершина 2: 2 - Степень
        Вершина 3: 2 - Степень
    (3) Список рёбер графа:
        Ребро: 1 - 2
        Ребро: 1 - 3
        Ребро: 2 - 3
    (4) Матрица достижимости:
        1    1    1    
        1    1    1    
        1    1    1   
    ```
2. ##### N=4, ориентированный:
- Input:
    ```
    4
    0 1 0 1
    0 0 1 1
    0 1 0 0
    1 0 1 0
    ```
- Output:
    ```
    (1) Эйлеровость : false
    (2) Cтепени вершин
        Вершина: 1. Исходящая степень - 2. Входящая степень - 1
        Вершина: 2. Исходящая степень - 2. Входящая степень - 2
        Вершина: 3. Исходящая степень - 1. Входящая степень - 2
        Вершина: 4. Исходящая степень - 2. Входящая степень - 2
    (3) Список рёбер графа:
        Ребро: 1 -> 2
        Ребро: 1 -> 4
        Ребро: 2 -> 3
        Ребро: 2 -> 4
        Ребро: 3 -> 2
        Ребро: 4 -> 1
        Ребро: 4 -> 3
    (4) Матрица достижимости:
        1    1    1    1    
        1    1    1    1    
        1    1    1    1    
        1    1    1    1   
    ```
2. ##### N=7, ориентированный:
- Input:
    ```
    7
    0 1 1 0 0 0 0
    1 0 1 1 1 0 1
    0 0 0 0 1 0 0
    1 0 0 0 1 0 1
    0 0 0 0 0 0 0
    0 0 0 1 1 0 1
    0 0 0 0 1 0 0
    ```
- Output:
    ```
    (1) Эйлеровость : false
    (2) Cтепени вершин
        Вершина: 1. Исходящая степень - 2. Входящая степень - 2
        Вершина: 2. Исходящая степень - 5. Входящая степень - 1
        Вершина: 3. Исходящая степень - 1. Входящая степень - 2
        Вершина: 4. Исходящая степень - 3. Входящая степень - 2
        Вершина: 5. Исходящая степень - 0. Входящая степень - 5
        Вершина: 6. Исходящая степень - 3. Входящая степень - 0
        Вершина: 7. Исходящая степень - 1. Входящая степень - 3
    (3) Список рёбер графа:
        Ребро: 1 -> 2
        Ребро: 1 -> 3
        Ребро: 2 -> 1
        Ребро: 2 -> 3
        Ребро: 2 -> 4
        Ребро: 2 -> 5
        Ребро: 2 -> 7
        Ребро: 3 -> 5
        Ребро: 4 -> 1
        Ребро: 4 -> 5
        Ребро: 4 -> 7
        Ребро: 6 -> 4
        Ребро: 6 -> 5
        Ребро: 6 -> 7
        Ребро: 7 -> 5
    (4) Матрица достижимости:
        1    1    1    1    1    0    1    
        1    1    1    1    1    0    1    
        0    0    0    0    1    0    0    
        1    1    1    1    1    0    1    
        0    0    0    0    0    0    0    
        1    1    1    1    1    0    1    
        0    0    0    0    1    0    0    
    ```


  
